# Copilot Instructions for DIAS Package Creator

This document contains specific instructions for the GitHub Copilot agent when working on this project.

## Context
We are building a **standalone desktop GUI application** to create DIAS packages. The application must be production-ready, testable, and capable of packaging into a single executable file.

## General Guidelines
1.  **Native Application**: This is a standalone desktop application. Focus on native Python execution.
2.  **OS Compatibility**: While the user is on Linux, write cross-platform compatible path handling using `os.path` or `pathlib`.
3.  **Error Handling**:
    *   Wrap file I/O operations in `try...except` blocks.
    *   Provide descriptive error messages for the user (to be displayed in GUI logs).
    *   Fail gracefully; do not crash the application on bad input.

## GUI Development (Tkinter)
*   Use `tkinter` and `tkinter.ttk` for the interface.
*   Separate GUI layout code (`View`) from business logic (`Controller`).
*   **Threading**: heavy operations (file copying, hashing) **MUST** run in a separate thread to prevent the GUI from freezing. Use `threading` or `concurrent.futures`.
*   Connect progress updates from the backend to a progress bar in the GUI using queues or callbacks.

## XML Generation
*   Reuse the logic in `src/dias_package_creator/xml_generators.py` and `src/dias_package_creator/submission_description_generator.py` where possible.
*   Ensure generated XMLs reference the local XSD files (`dias_mets.xsd`, etc.) correctly.
*   **Mappings**:
    *   `mets.xml`: Generated by `DIASMetsGenerator`.
    *   `premis.xml`: Generated by `DIASPremisGenerator` / `ComprehensivePremisGenerator`.
    *   `info.xml`: Generated by `SubmissionDescriptionMetsGenerator`.

## File Processing
*   Use `hashlib` for checksums (calculate in chunks to handle large files specific to preservation contexts).
*   Use `shutil` for file copying.
*   Ensure permissions are handled (read-only files).

## Testing
*   Use `unittest` framework.
*   Mock file system operations for logic tests where possible.
*   Create integration tests that actually generate XMLs and validate them against the XSDs if `xmlschema` library or similar is available (or simple string presence checks).

## Packaging
*   Be prepared to generate a `pyinstaller` command or `.spec` file that includes the `src` packages and necessary non-code files (like XSDs if they need to be bundled).
